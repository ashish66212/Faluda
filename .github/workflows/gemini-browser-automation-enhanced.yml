name: Gemini Autonomous AI Browser Agent

on:
  workflow_dispatch:
      - main   # is branch pe hi manual trigger allow hoga
    inputs:
      task_description:
        description: 'High-level task for Gemini AI (e.g., "Book train ticket Delhi to Mumbai next Thursday")'
        required: true
        default: 'Research the latest developments in AI and create a summary'
        
      headless:
        description: 'Run browser in headless mode'
        required: false
        default: 'false'
      timeout_minutes:
        description: 'Maximum runtime in minutes'
        required: false
        default: '45'
      enable_web_search:
        description: 'Enable Google Search grounding for research'
        required: false
        default: 'true'
      model_variant:
        description: 'Gemini model (flash-exp or thinking-exp for deep reasoning)'
        required: false
        default: 'gemini-2.0-flash-thinking-exp'

jobs:
  autonomous-browser-agent:
    runs-on: ubuntu-latest
    timeout-minutes: ${{ github.event.inputs.timeout_minutes || 45 }}
    
    steps:
      - name: Setup Autonomous AI Environment
        run: |
          echo "ü§ñ Setting up Gemini Autonomous AI Browser Agent"
          mkdir -p browser-automation/videos browser-automation/screenshots browser-automation/downloads browser-automation/logs
          cd browser-automation

      - name: Create Enhanced package.json
        run: |
          cd browser-automation
          cat > package.json << 'PACKAGE_EOF'
          {
            "name": "gemini-autonomous-browser-agent",
            "version": "2.0.0",
            "description": "Fully autonomous AI agent powered by Gemini 2.0 with deep reasoning, web search, and browser control",
            "main": "autonomous-agent.js",
            "type": "module",
            "dependencies": {
              "@google/generative-ai": "^0.21.0",
              "express": "^4.21.2",
              "playwright": "^1.49.1",
              "playwright-extra": "^4.3.6",
              "puppeteer-extra-plugin-stealth": "^2.11.2",
              "cheerio": "^1.0.0"
            }
          }
          PACKAGE_EOF

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: 'browser-automation/package.json'

      - name: Cache Playwright Browsers
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ hashFiles('browser-automation/package.json') }}
          restore-keys: |
            ${{ runner.os }}-playwright-

      - name: Install dependencies
        working-directory: browser-automation
        run: npm install

      - name: Install Playwright browsers
        working-directory: browser-automation
        if: steps.playwright-cache.outputs.cache-hit != 'true'
        run: npx playwright install chromium --with-deps
      
      - name: Install Playwright system dependencies
        working-directory: browser-automation
        if: steps.playwright-cache.outputs.cache-hit == 'true'
        run: npx playwright install-deps chromium

      - name: Setup ngrok
        run: |
          echo "üì° Installing ngrok..."
          wget -q https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-linux-amd64.tgz
          tar xzf ngrok-v3-stable-linux-amd64.tgz
          sudo mv ngrok /usr/local/bin/
          ngrok authtoken ${{ secrets.NGROK_AUTHTOKEN }}
          echo "‚úÖ ngrok authenticated"

      - name: Create Autonomous AI Agent Controller
        run: |
          cd browser-automation
          cat > autonomous-agent.js << 'CONTROLLER_EOF'
          import { chromium } from 'playwright';
          import express from 'express';
          import { GoogleGenerativeAI } from '@google/generative-ai';
          import * as cheerio from 'cheerio';
          import fs from 'fs';
          import path from 'path';

          const app = express();
          app.use(express.json());

          const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
          const MODEL_NAME = process.env.MODEL_VARIANT || 'gemini-2.0-flash-thinking-exp';
          const ENABLE_WEB_SEARCH = process.env.ENABLE_WEB_SEARCH === 'true';

          const model = genAI.getGenerativeModel({ 
            model: MODEL_NAME,
            generationConfig: {
              temperature: 1.0,
              topP: 0.95,
              topK: 40,
              maxOutputTokens: 8192,
            },
            tools: ENABLE_WEB_SEARCH ? [{ googleSearch: {} }] : []
          });

          let browser = null;
          let page = null;
          let context = null;
          let actionLog = [];
          let screenshotCounter = 0;
          let planSteps = [];
          let currentStepIndex = 0;

          const HEADLESS = process.env.HEADLESS === 'true';
          const TASK_DESCRIPTION = process.env.TASK_DESCRIPTION || 'Research and summarize';

          const SYSTEM_PROMPT = `You are an AUTONOMOUS AI AGENT with complete control over a Chrome browser. Your mission is to execute user requests END-TO-END without waiting for step-by-step instructions.

Core Capabilities:
  ‚Ä¢ üß† DEEP REASONING: Break complex tasks into multi-step plans, analyze situations, adapt dynamically
  ‚Ä¢ üîç WEB SEARCH: Access real-time information via Google Search grounding (when enabled)
  ‚Ä¢ üåê BROWSER CONTROL: Navigate, click, scroll, fill forms, download, upload, extract data
  ‚Ä¢ üìÑ DOCUMENT UNDERSTANDING: Read and analyze long documents, research papers, PDFs
  ‚Ä¢ üî¢ ADVANCED LOGIC: Solve complex math, logical reasoning, multi-step problems
  ‚Ä¢ ü§ñ SCREEN CONTROL: Identify UI elements, buttons, forms and interact with them intelligently

Operating Rules:
  1. AUTONOMY FIRST: Plan and execute independently. Only ask for clarification when absolutely necessary
  2. MULTI-STEP PLANNING: Break requests into concrete action steps with clear success criteria
  3. DYNAMIC ADAPTATION: If obstacles occur (errors, unexpected layouts), adjust your plan
  4. RESEARCH WHEN NEEDED: Use web search to gather information you don't have
  5. PRIORITIZE SAFETY: Verify actions before submitting forms with payments or sensitive data
  6. OPTIMIZE FOR SPEED: Take the most efficient path, avoid unnecessary steps
  7. TRACK PROGRESS: Log all actions, decisions, and reasoning in detail
  8. PROVIDE SUMMARIES: After completing tasks, give structured reports with key findings

Current Task: "${TASK_DESCRIPTION}"

Available Browser Actions:
  * goto(url): Navigate to a URL
  * click(selector): Click an element
  * type(selector, text): Fill input fields
  * scroll(direction, amount): Scroll page
  * extract_text(selector): Get text content
  * extract_data(): Get structured page data
  * screenshot(): Capture current state
  * wait(seconds): Wait for page to load
  * download(url): Download files
  * evaluate_js(code): Run JavaScript in browser

Think step-by-step:
  1) Analyze the user request
  2) Create a multi-step plan
  3) Execute each step while monitoring results
  4) Adjust plan if needed
  5) Provide final summary

Be proactive, decisive, and thorough. Act as if you're a skilled human operator with AI superpowers.`;

          function log(message, level = 'INFO') {
            const timestamp = new Date().toISOString();
            const logMessage = `[${timestamp}] [${level}] ${message}`;
            console.log(logMessage);
            actionLog.push({ timestamp, level, message });
            
            fs.appendFileSync('logs/automation.log', logMessage + '\n');
          }

          async function initBrowser() {
            log('üé≠ Initializing stealth browser for autonomous operation...');
            
            browser = await chromium.launch({
              headless: HEADLESS,
              args: [
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage',
                '--disable-blink-features=AutomationControlled',
                '--disable-features=IsolateOrigins,site-per-process',
                '--window-size=1920,1080'
              ]
            });

            context = await browser.newContext({
              viewport: { width: 1920, height: 1080 },
              userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36',
              acceptDownloads: true,
              recordVideo: {
                dir: 'videos/',
                size: { width: 1920, height: 1080 }
              },
              permissions: ['geolocation', 'notifications']
            });

            await context.addInitScript(() => {
              Object.defineProperty(navigator, 'webdriver', { get: () => undefined });
              Object.defineProperty(navigator, 'plugins', { get: () => [1, 2, 3, 4, 5] });
              Object.defineProperty(navigator, 'languages', { get: () => ['en-US', 'en'] });
              window.chrome = { runtime: {} };
            });

            page = await context.newPage();
            
            page.on('console', msg => log(`Browser: ${msg.text()}`));
            page.on('pageerror', err => log(`Error: ${err.message}`, 'ERROR'));
            page.on('download', download => log(`Download: ${download.suggestedFilename()}`));
            
            log('‚úÖ Browser ready for autonomous operation');
            return page;
          }

          async function takeScreenshot(name = null) {
            if (!page) return null;
            
            screenshotCounter++;
            const filename = name || `step-${currentStepIndex}-${screenshotCounter}-${Date.now()}.png`;
            const filepath = path.join('screenshots', filename);
            
            await page.screenshot({ path: filepath, fullPage: false });
            log(`üì∏ Screenshot: ${filename}`);
            return filepath;
          }

          async function getPageContext() {
            const url = page.url();
            const title = await page.title();
            const html = await page.content();
            const $ = cheerio.load(html);
            
            $('script, style, noscript').remove();
            const visibleText = $('body').text().replace(/\s+/g, ' ').trim().substring(0, 5000);
            
            const buttons = await page.$$eval('button, a.button, input[type="submit"]', 
              elements => elements.slice(0, 20).map(el => ({
                text: el.textContent?.trim() || el.value,
                selector: el.id ? `#${el.id}` : el.className ? `.${el.className.split(' ')[0]}` : el.tagName
              }))
            );
            
            const inputs = await page.$$eval('input, textarea, select', 
              elements => elements.slice(0, 20).map(el => ({
                type: el.type || 'text',
                name: el.name || el.id,
                placeholder: el.placeholder,
                selector: el.id ? `#${el.id}` : el.name ? `[name="${el.name}"]` : el.tagName
              }))
            );
            
            return {
              url,
              title,
              visibleText,
              buttons,
              inputs,
              hasImages: $('img').length > 0,
              hasVideos: $('video').length > 0,
              formCount: $('form').length
            };
          }

          async function executeAction(action) {
            log(`‚ö° Executing: ${action.type} - ${JSON.stringify(action.params)}`, 'ACTION');
            
            try {
              switch (action.type) {
                case 'goto':
                  await page.goto(action.params.url, { waitUntil: 'networkidle', timeout: 30000 });
                  break;
                case 'click':
                  await page.click(action.params.selector, { timeout: 10000 });
                  await page.waitForLoadState('networkidle', { timeout: 10000 }).catch(() => {});
                  break;
                case 'type':
                  await page.fill(action.params.selector, action.params.text);
                  break;
                case 'press':
                  await page.keyboard.press(action.params.key);
                  break;
                case 'scroll':
                  await page.evaluate((params) => {
                    window.scrollBy(0, params.direction === 'down' ? params.amount : -params.amount);
                  }, action.params);
                  break;
                case 'wait':
                  await page.waitForTimeout(action.params.seconds * 1000);
                  break;
                case 'screenshot':
                  await takeScreenshot(action.params.name);
                  break;
                case 'extract_text':
                  const text = await page.textContent(action.params.selector);
                  log(`Extracted: ${text}`);
                  return text;
                case 'evaluate':
                  return await page.evaluate(action.params.code);
                default:
                  log(`Unknown action type: ${action.type}`, 'WARN');
              }
              
              log(`‚úÖ Action completed successfully`, 'SUCCESS');
              return { success: true };
            } catch (error) {
              log(`‚ùå Action failed: ${error.message}`, 'ERROR');
              return { success: false, error: error.message };
            }
          }

          async function askGemini(prompt, includePageContext = true) {
            let fullPrompt = SYSTEM_PROMPT + '\n\n' + prompt;
            
            if (includePageContext && page) {
              const context = await getPageContext();
              fullPrompt += `\n\nCurrent Page Context:\n${JSON.stringify(context, null, 2)}`;
            }
            
            log('ü§ñ Querying Gemini AI for decision...');
            
            try {
              const result = await model.generateContent(fullPrompt);
              const response = result.response.text();
              
              if (result.response.groundingMetadata) {
                log('üîç Web search used:', 'INFO');
                log(JSON.stringify(result.response.groundingMetadata.webSearchQueries || []), 'INFO');
              }
              
              log(`üí¨ Gemini response: ${response.substring(0, 200)}...`);
              return response;
            } catch (error) {
              log(`‚ùå Gemini API error: ${error.message}`, 'ERROR');
              throw error;
            }
          }

          async function createExecutionPlan(taskDescription) {
            log('üìã Creating autonomous execution plan...');
            
            const planningPrompt = `Task: "${taskDescription}"

Create a detailed, step-by-step execution plan to complete this task autonomously. 
Think deeply about:
  1. What information do you need? (Use web search if needed)
  2. What websites or tools are best for this task?
  3. What steps must happen in sequence?
  4. What could go wrong and how to handle it?
  5. What's the final deliverable?

Return your plan as a JSON array of steps:
[
  {
    "step": 1,
    "action": "research",
    "description": "Search for best train booking websites in India",
    "reasoning": "Need to find official IRCTC or reliable booking platforms"
  },
  {
    "step": 2,
    "action": "navigate",
    "description": "Go to selected booking website",
    "url": "https://www.irctc.co.in"
  },
  ...
]

Be thorough and proactive. Plan for success.`;

            const response = await askGemini(planningPrompt, false);
            
            try {
              const jsonMatch = response.match(/\[[\s\S]*\]/);
              if (jsonMatch) {
                planSteps = JSON.parse(jsonMatch[0]);
                log(`‚úÖ Created plan with ${planSteps.length} steps`);
                planSteps.forEach((step, i) => {
                  log(`  ${i + 1}. ${step.description}`);
                });
                return planSteps;
              }
            } catch (e) {
              log('‚ö†Ô∏è Could not parse plan as JSON, using text-based planning', 'WARN');
            }
            
            planSteps = [{ step: 1, action: 'execute', description: 'Execute task autonomously' }];
            return planSteps;
          }

          async function executeTask() {
            log('üöÄ Starting autonomous task execution...', 'INFO');
            log(`Task: ${TASK_DESCRIPTION}`);
            
            await initBrowser();
            
            const plan = await createExecutionPlan(TASK_DESCRIPTION);
            
            for (let i = 0; i < plan.length; i++) {
              currentStepIndex = i + 1;
              const step = plan[i];
              
              log(`\nüìç STEP ${currentStepIndex}/${plan.length}: ${step.description}`, 'INFO');
              
              await takeScreenshot(`before-step-${currentStepIndex}`);
              
              const stepPrompt = `You are now executing step ${currentStepIndex} of your plan:
              
Step: ${step.description}
Reasoning: ${step.reasoning || 'N/A'}

Current page context will be provided below.

Based on the current state, what specific browser actions should you take?
Respond with a JSON array of actions:

[
  { "type": "goto", "params": { "url": "https://example.com" } },
  { "type": "click", "params": { "selector": "#search-button" } },
  { "type": "type", "params": { "selector": "#query", "text": "search term" } },
  { "type": "wait", "params": { "seconds": 2 } },
  { "type": "screenshot", "params": { "name": "result" } }
]

Available actions: goto, click, type, press, scroll, wait, screenshot, extract_text, evaluate

Be specific and use proper selectors (ID, class, or CSS selector).`;

              const response = await askGemini(stepPrompt, true);
              
              const jsonMatch = response.match(/\[[\s\S]*?\](?=\s*$|\s*```|\s*\n\n)/);
              if (jsonMatch) {
                try {
                  const actions = JSON.parse(jsonMatch[0]);
                  
                  for (const action of actions) {
                    await executeAction(action);
                    await page.waitForTimeout(1000);
                  }
                  
                  await takeScreenshot(`after-step-${currentStepIndex}`);
                } catch (e) {
                  log(`‚ö†Ô∏è Error parsing/executing actions: ${e.message}`, 'ERROR');
                }
              } else {
                log('‚ö†Ô∏è No valid action JSON found in response', 'WARN');
              }
            }
            
            log('\n‚úÖ Task execution completed', 'SUCCESS');
            
            const summaryPrompt = `Task completed: "${TASK_DESCRIPTION}"

Based on all the actions taken (logged above), provide a concise summary report:
  1. What was accomplished?
  2. Key findings or results
  3. Any issues encountered
  4. Final status (success/partial/failed)

Format as a clear, structured summary.`;

            const summary = await askGemini(summaryPrompt, false);
            log('\nüìä FINAL SUMMARY:\n' + summary, 'SUMMARY');
            
            return { success: true, summary, actionLog };
          }

          app.get('/status', (req, res) => {
            res.json({
              status: 'running',
              task: TASK_DESCRIPTION,
              currentStep: currentStepIndex,
              totalSteps: planSteps.length,
              actionCount: actionLog.length
            });
          });

          app.get('/logs', (req, res) => {
            res.json({ logs: actionLog });
          });

          app.post('/stop', async (req, res) => {
            log('üõë Stop requested by user');
            if (browser) await browser.close();
            res.json({ message: 'Stopped' });
            process.exit(0);
          });

          const PORT = process.env.PORT || 3000;
          app.listen(PORT, '0.0.0.0', () => {
            log(`üåê Control server running on port ${PORT}`);
            log(`üîó Access via ngrok tunnel for remote monitoring`);
          });

          executeTask().then(async (result) => {
            log('üé¨ Task completed, keeping server alive for review...');
            log(`Total actions logged: ${actionLog.length}`);
            
            await page.waitForTimeout(60000);
            
            if (browser) await browser.close();
            log('üëã Browser closed, shutting down...');
            process.exit(0);
          }).catch(async (error) => {
            log(`‚ùå Fatal error: ${error.message}`, 'ERROR');
            if (browser) await browser.close();
            process.exit(1);
          });
          CONTROLLER_EOF

      - name: Start ngrok tunnel
        run: |
          cd browser-automation
          echo "üîó Starting ngrok tunnel..."
          ngrok http 3000 --log=stdout > ngrok.log 2>&1 &
          sleep 5
          
          NGROK_URL=$(curl -s http://localhost:4040/api/tunnels | grep -o '"public_url":"https://[^"]*' | grep -o 'https://.*' | head -1)
          
          if [ -z "$NGROK_URL" ]; then
            echo "‚ö†Ô∏è Could not get ngrok URL, checking logs..."
            cat ngrok.log || true
            NGROK_URL="http://localhost:3000"
          fi
          
          echo "NGROK_URL=$NGROK_URL" >> $GITHUB_ENV
          echo "‚úÖ Ngrok URL: $NGROK_URL"

      - name: Execute Autonomous AI Agent
        working-directory: browser-automation
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          TASK_DESCRIPTION: ${{ github.event.inputs.task_description }}
          HEADLESS: ${{ github.event.inputs.headless }}
          ENABLE_WEB_SEARCH: ${{ github.event.inputs.enable_web_search }}
          MODEL_VARIANT: ${{ github.event.inputs.model_variant }}
          PORT: 3000
        run: |
          echo "ü§ñ Launching Gemini Autonomous AI Agent..."
          echo "üìù Task: $TASK_DESCRIPTION"
          echo "üß† Model: $MODEL_VARIANT"
          echo "üîç Web Search: $ENABLE_WEB_SEARCH"
          echo "üé≠ Headless: $HEADLESS"
          echo ""
          
          node autonomous-agent.js
          EXIT_CODE=$?
          
          echo ""
          echo "=================================="
          echo "üèÅ Agent execution finished"
          echo "Exit code: $EXIT_CODE"
          echo "=================================="
          
          exit $EXIT_CODE

      - name: Upload Screenshots
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: screenshots-${{ github.run_number }}
          path: browser-automation/screenshots/
          retention-days: 30

      - name: Upload Videos
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: videos-${{ github.run_number }}
          path: browser-automation/videos/
          retention-days: 30

      - name: Upload Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: logs-${{ github.run_number }}
          path: browser-automation/logs/
          retention-days: 30

      - name: Generate Summary Report
        if: always()
        run: |
          echo "## ü§ñ Autonomous AI Agent Execution Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìã Task Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Task**: ${{ github.event.inputs.task_description }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Model**: ${{ github.event.inputs.model_variant }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Web Search**: ${{ github.event.inputs.enable_web_search }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Headless Mode**: ${{ github.event.inputs.headless }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Run Number**: #${{ github.run_number }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          SCREENSHOT_COUNT=$(find browser-automation/screenshots -type f 2>/dev/null | wc -l || echo "0")
          VIDEO_COUNT=$(find browser-automation/videos -type f 2>/dev/null | wc -l || echo "0")
          
          echo "### üìä Execution Metrics" >> $GITHUB_STEP_SUMMARY
          echo "- üì∏ Screenshots Captured: $SCREENSHOT_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "- üé¨ Videos Recorded: $VIDEO_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -f browser-automation/logs/automation.log ]; then
            echo "### üìù Key Log Entries" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            grep -E "\[SUCCESS\]|\[ERROR\]|\[SUMMARY\]" browser-automation/logs/automation.log | tail -20 >> $GITHUB_STEP_SUMMARY || true
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üì¶ Artifacts" >> $GITHUB_STEP_SUMMARY
          echo "Download screenshots, videos, and full logs from the artifacts section above." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Agent execution completed**" >> $GITHUB_STEP_SUMMARY

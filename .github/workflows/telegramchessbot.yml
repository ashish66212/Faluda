name: Run Telegram Chess Bot

on:
  workflow_dispatch:   # manually GitHub Actions se run karne ke liye

jobs:
  run-bot:
    runs-on: ubuntu-latest
    timeout-minutes: 360  # 6 hours max runtime

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.11"

    - name: Cache pip
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y stockfish
        pip install --upgrade pip
        pip install python-telegram-bot python-chess nest_asyncio

    - name: Create bot file
      run: |
        cat << 'EOFBOT' > chess_bot.py
        import os
        import chess
        import chess.engine
        import chess.polyglot
        import nest_asyncio
        nest_asyncio.apply()

        from telegram import Update
        from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, filters, ContextTypes

        TOKEN = os.environ.get("TELEGRAM_TOKEN")
        STOCKFISH_PATH = "/usr/games/stockfish"
        ENGINE_TIME = 0.8
        ENGINE_MATE_DEPTH = 20
        ENGINE_FALLBACK_DEPTH = 15
        MAX_TRAP_CHECKS = 1000

        print(f"Starting Telegram Chess Bot...")
        print(f"Stockfish path: {STOCKFISH_PATH}")

        engine = chess.engine.SimpleEngine.popen_uci(STOCKFISH_PATH)

        TRAPBOOK = [
            {"name":"Italian Game Trap","side":"white","sequence":["e2e4","e7e5","g1f3","b8c6"],"priority":76, "fallback_trap":"Legal's Mate Trap"},
            {"name":"Fool's Mate","side":"black","sequence":["f2f3","e7e5","g2g4","d8h4"],"priority":100, "fallback_trap":None},
            {"name":"Legal's Mate Trap","side":"white","sequence":["e2e4","e7e5","d2d3","b8c6","f1c4","g8f6","g1f3","d8e7","f3g5"],"priority":50, "fallback_trap":None},
        ]
        TRAPBOOK.sort(key=lambda t: -t.get("priority", 0))
        TRAPBOOK_MAP = {trap["name"]: trap for trap in TRAPBOOK}

        games = {}

        def find_applicable_trap_manual(board: chess.Board, engine_side: str):
            played = [m.uci() for m in board.move_stack]
            checks = 0
            for trap in TRAPBOOK:
                if checks >= MAX_TRAP_CHECKS: 
                    break
                checks += 1
                if trap["side"] != engine_side:
                    continue
                seq = trap["sequence"]
                if len(played) < len(seq):
                    continue
                if played[:len(seq)] == seq:
                    return trap["name"]
            return None

        def get_engine_move(board: chess.Board, color_to_move: str, time_limit=ENGINE_TIME):
            try:
                result = engine.play(board, chess.engine.Limit(time=time_limit))
                return result.move
            except:
                legal_moves = list(board.legal_moves)
                return legal_moves[0] if legal_moves else None

        def get_bot_move(board: chess.Board, engine_side: str, active_trap=None):
            if active_trap and active_trap in TRAPBOOK_MAP:
                trap = TRAPBOOK_MAP[active_trap]
                played = [m.uci() for m in board.move_stack]
                seq = trap["sequence"]
                if len(played) < len(seq) and played == seq[:len(played)]:
                    next_uci = seq[len(played)]
                    try:
                        mv = chess.Move.from_uci(next_uci)
                        if mv in board.legal_moves:
                            return mv, active_trap
                    except:
                        pass
            
            detected_trap = find_applicable_trap_manual(board, engine_side)
            if detected_trap:
                return get_engine_move(board, engine_side), detected_trap
            
            mv = get_engine_move(board, engine_side)
            return mv, "Stockfish"

        async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
            chat_id = update.effective_chat.id
            user_color = "white"
            if context.args and context.args[0].lower() in ["white", "black"]:
                user_color = context.args[0].lower()
            
            board = chess.Board()
            games[chat_id] = {
                "board": board,
                "user_color": user_color,
                "active_trap": None
            }
            
            await update.message.reply_text(f"Game started! You are {user_color}. Send moves in UCI format (e.g., e2e4)")
            
            if user_color == "black":
                engine_side = "white"
                mv, trap_name = get_bot_move(board, engine_side)
                board.push(mv)
                games[chat_id]["active_trap"] = trap_name if trap_name != "Stockfish" else None
                await update.message.reply_text(f"{mv.uci()}  ({trap_name})")

        async def handle_move(update: Update, context: ContextTypes.DEFAULT_TYPE):
            chat_id = update.effective_chat.id
            if chat_id not in games:
                await update.message.reply_text("Start a game first with /start [white|black]")
                return
            
            game = games[chat_id]
            board = game["board"]
            user_color = game["user_color"]
            
            move_text = update.message.text.strip().lower()
            try:
                user_move = chess.Move.from_uci(move_text)
                if user_move not in board.legal_moves:
                    await update.message.reply_text("Illegal move!")
                    return
            except:
                await update.message.reply_text("Invalid move format. Use UCI (e.g., e2e4)")
                return
            
            board.push(user_move)
            if board.is_game_over():
                await update.message.reply_text(f"Game over: {board.result()}")
                del games[chat_id]
                return
            
            engine_side = "black" if user_color=="white" else "white"
            mv, trap_name = get_bot_move(board, engine_side, game.get("active_trap"))
            board.push(mv)
            game["active_trap"] = trap_name if trap_name not in ["Stockfish", "King-hunt"] else None
            await update.message.reply_text(f"{mv.uci()}  ({trap_name})")

            if board.is_game_over():
                await update.message.reply_text(f"Game over: {board.result()}")
                del games[chat_id]

        async def sync(update: Update, context: ContextTypes.DEFAULT_TYPE):
            chat_id = update.effective_chat.id
            if chat_id not in games:
                await update.message.reply_text("Start a game first with /start")
                return
            if not context.args:
                await update.message.reply_text("Send FEN after /sync")
                return
            fen = " ".join(context.args)
            try:
                board = chess.Board(fen)
                games[chat_id]["board"] = board
                await update.message.reply_text("Board synced to provided FEN.")
                user_color = games[chat_id]["user_color"]
                engine_side = "black" if user_color=="white" else "white"
                is_player_turn = (board.turn and user_color=="white") or (not board.turn and user_color=="black")
                if not is_player_turn:
                    mv, trap_name = get_bot_move(board, engine_side)
                    board.push(mv)
                    await update.message.reply_text(f"{mv.uci()}  ({trap_name})")
            except Exception as e:
                await update.message.reply_text(f"Invalid FEN: {e}")

        print("Building bot application...")
        app = ApplicationBuilder().token(TOKEN).build()
        app.add_handler(CommandHandler("start", start))
        app.add_handler(CommandHandler("sync", sync))
        app.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND), handle_move))

        print("Bot is running... Press Ctrl+C to stop")
        app.run_polling()
        EOFBOT

    - name: Run bot
      env:
        TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
      run: |
        if [ -z "$TELEGRAM_TOKEN" ]; then
          echo "Error: TELEGRAM_TOKEN secret not set!"
          exit 1
        fi
        echo "Starting Telegram Chess Bot..."
        python chess_bot.py
